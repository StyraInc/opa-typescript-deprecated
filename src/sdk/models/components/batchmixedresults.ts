/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { remap as remap$ } from "../../../lib/primitives.js";
import { Provenance, Provenance$ } from "./provenance.js";
import { Result, Result$ } from "./result.js";
import * as z from "zod";

export type Location = {
    file: string;
    row: number;
    col: number;
};

export type Errors = {
    code: string;
    message: string;
    location?: Location | undefined;
};

export type ServerError = {
    code: string;
    message: string;
    errors?: Array<Errors> | undefined;
    decisionId?: string | undefined;
    httpStatusCode?: string | undefined;
};

export type ResponsesSuccessfulPolicyResponse = {
    /**
     * The base or virtual document referred to by the URL path. If the path is undefined, this key will be omitted.
     */
    result?: Result | undefined;
    /**
     * If query metrics are enabled, this field contains query performance metrics collected during the parse, compile, and evaluation steps.
     */
    metrics?: { [k: string]: any } | undefined;
    /**
     * If decision logging is enabled, this field contains a string that uniquely identifies the decision. The identifier will be included in the decision log event for this decision. Callers can use the identifier for correlation purposes.
     */
    decisionId?: string | undefined;
    /**
     * Provenance information can be requested on individual API calls and are returned inline with the API response. To obtain provenance information on an API call, specify the `provenance=true` query parameter when executing the API call.
     */
    provenance?: Provenance | undefined;
    httpStatusCode?: string | undefined;
};

export type Responses =
    | (ResponsesSuccessfulPolicyResponse & { httpStatusCode: "200" })
    | (ServerError & { httpStatusCode: "500" });

export type BatchMixedResults = {
    batchDecisionId?: string | undefined;
    /**
     * If query metrics are enabled, this field contains query performance metrics collected during the parse, compile, and evaluation steps.
     */
    metrics?: { [k: string]: any } | undefined;
    responses?:
        | {
              [k: string]:
                  | (ResponsesSuccessfulPolicyResponse & { httpStatusCode: "200" })
                  | (ServerError & { httpStatusCode: "500" });
          }
        | undefined;
};

/** @internal */
export namespace Location$ {
    export const inboundSchema: z.ZodType<Location, z.ZodTypeDef, unknown> = z.object({
        file: z.string(),
        row: z.number().int(),
        col: z.number().int(),
    });

    export type Outbound = {
        file: string;
        row: number;
        col: number;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Location> = z.object({
        file: z.string(),
        row: z.number().int(),
        col: z.number().int(),
    });
}

/** @internal */
export namespace Errors$ {
    export const inboundSchema: z.ZodType<Errors, z.ZodTypeDef, unknown> = z.object({
        code: z.string(),
        message: z.string(),
        location: z.lazy(() => Location$.inboundSchema).optional(),
    });

    export type Outbound = {
        code: string;
        message: string;
        location?: Location$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Errors> = z.object({
        code: z.string(),
        message: z.string(),
        location: z.lazy(() => Location$.outboundSchema).optional(),
    });
}

/** @internal */
export namespace ServerError$ {
    export const inboundSchema: z.ZodType<ServerError, z.ZodTypeDef, unknown> = z
        .object({
            code: z.string(),
            message: z.string(),
            errors: z.array(z.lazy(() => Errors$.inboundSchema)).optional(),
            decision_id: z.string().optional(),
            http_status_code: z.string().optional(),
        })
        .transform((v) => {
            return remap$(v, {
                decision_id: "decisionId",
                http_status_code: "httpStatusCode",
            });
        });

    export type Outbound = {
        code: string;
        message: string;
        errors?: Array<Errors$.Outbound> | undefined;
        decision_id?: string | undefined;
        http_status_code?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ServerError> = z
        .object({
            code: z.string(),
            message: z.string(),
            errors: z.array(z.lazy(() => Errors$.outboundSchema)).optional(),
            decisionId: z.string().optional(),
            httpStatusCode: z.string().optional(),
        })
        .transform((v) => {
            return remap$(v, {
                decisionId: "decision_id",
                httpStatusCode: "http_status_code",
            });
        });
}

/** @internal */
export namespace ResponsesSuccessfulPolicyResponse$ {
    export const inboundSchema: z.ZodType<
        ResponsesSuccessfulPolicyResponse,
        z.ZodTypeDef,
        unknown
    > = z
        .object({
            result: Result$.inboundSchema.optional(),
            metrics: z.record(z.any()).optional(),
            decision_id: z.string().optional(),
            provenance: Provenance$.inboundSchema.optional(),
            http_status_code: z.string().optional(),
        })
        .transform((v) => {
            return remap$(v, {
                decision_id: "decisionId",
                http_status_code: "httpStatusCode",
            });
        });

    export type Outbound = {
        result?: Result$.Outbound | undefined;
        metrics?: { [k: string]: any } | undefined;
        decision_id?: string | undefined;
        provenance?: Provenance$.Outbound | undefined;
        http_status_code?: string | undefined;
    };

    export const outboundSchema: z.ZodType<
        Outbound,
        z.ZodTypeDef,
        ResponsesSuccessfulPolicyResponse
    > = z
        .object({
            result: Result$.outboundSchema.optional(),
            metrics: z.record(z.any()).optional(),
            decisionId: z.string().optional(),
            provenance: Provenance$.outboundSchema.optional(),
            httpStatusCode: z.string().optional(),
        })
        .transform((v) => {
            return remap$(v, {
                decisionId: "decision_id",
                httpStatusCode: "http_status_code",
            });
        });
}

/** @internal */
export namespace Responses$ {
    export const inboundSchema: z.ZodType<Responses, z.ZodTypeDef, unknown> = z.union([
        z
            .lazy(() => ResponsesSuccessfulPolicyResponse$.inboundSchema)
            .and(
                z
                    .object({ http_status_code: z.literal("200") })
                    .transform((v) => ({ httpStatusCode: v.http_status_code }))
            ),
        z
            .lazy(() => ServerError$.inboundSchema)
            .and(
                z
                    .object({ http_status_code: z.literal("500") })
                    .transform((v) => ({ httpStatusCode: v.http_status_code }))
            ),
    ]);

    export type Outbound =
        | (ResponsesSuccessfulPolicyResponse$.Outbound & { http_status_code: "200" })
        | (ServerError$.Outbound & { http_status_code: "500" });
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Responses> = z.union([
        z
            .lazy(() => ResponsesSuccessfulPolicyResponse$.outboundSchema)
            .and(
                z
                    .object({ httpStatusCode: z.literal("200") })
                    .transform((v) => ({ http_status_code: v.httpStatusCode }))
            ),
        z
            .lazy(() => ServerError$.outboundSchema)
            .and(
                z
                    .object({ httpStatusCode: z.literal("500") })
                    .transform((v) => ({ http_status_code: v.httpStatusCode }))
            ),
    ]);
}

/** @internal */
export namespace BatchMixedResults$ {
    export const inboundSchema: z.ZodType<BatchMixedResults, z.ZodTypeDef, unknown> = z
        .object({
            batch_decision_id: z.string().optional(),
            metrics: z.record(z.any()).optional(),
            responses: z
                .record(
                    z.union([
                        z
                            .lazy(() => ResponsesSuccessfulPolicyResponse$.inboundSchema)
                            .and(
                                z
                                    .object({ http_status_code: z.literal("200") })
                                    .transform((v) => ({ httpStatusCode: v.http_status_code }))
                            ),
                        z
                            .lazy(() => ServerError$.inboundSchema)
                            .and(
                                z
                                    .object({ http_status_code: z.literal("500") })
                                    .transform((v) => ({ httpStatusCode: v.http_status_code }))
                            ),
                    ])
                )
                .optional(),
        })
        .transform((v) => {
            return remap$(v, {
                batch_decision_id: "batchDecisionId",
            });
        });

    export type Outbound = {
        batch_decision_id?: string | undefined;
        metrics?: { [k: string]: any } | undefined;
        responses?:
            | {
                  [k: string]:
                      | (ResponsesSuccessfulPolicyResponse$.Outbound & { http_status_code: "200" })
                      | (ServerError$.Outbound & { http_status_code: "500" });
              }
            | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, BatchMixedResults> = z
        .object({
            batchDecisionId: z.string().optional(),
            metrics: z.record(z.any()).optional(),
            responses: z
                .record(
                    z.union([
                        z
                            .lazy(() => ResponsesSuccessfulPolicyResponse$.outboundSchema)
                            .and(
                                z
                                    .object({ httpStatusCode: z.literal("200") })
                                    .transform((v) => ({ http_status_code: v.httpStatusCode }))
                            ),
                        z
                            .lazy(() => ServerError$.outboundSchema)
                            .and(
                                z
                                    .object({ httpStatusCode: z.literal("500") })
                                    .transform((v) => ({ http_status_code: v.httpStatusCode }))
                            ),
                    ])
                )
                .optional(),
        })
        .transform((v) => {
            return remap$(v, {
                batchDecisionId: "batch_decision_id",
            });
        });
}
